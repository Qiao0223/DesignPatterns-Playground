# 单例模式
旨在确保一个类只有 一个实例，并提供一个全局访问点来获取该实例。它常用于需要全局共享资源的场景，比如数据库连接池、配置管理器、日志管理器等。

## **单例模式的结构**

单例模式通常由以下几个组成部分构成：

- **私有构造函数**：防止外部直接创建该类的实例。
- **静态私有实例**：存储唯一实例。
- **公共静态方法**：提供对外访问唯一实例的方式。

## **实现方式**

单例模式有多种实现方式，以下是几种常见的实现方式。

### 1. **懒汉式（Lazy Singleton）**

懒汉式在第一次使用时才创建实例，适用于需要延迟初始化的场景。
缺点：没有线程安全机制，在多线程环境中可能会出现问题。

### 2. **饿汉式（Eager Singleton）**

饿汉式在类加载时就创建实例，适用于实例化较简单且没有资源消耗的场景。

- 在类加载时就创建实例，避免了多次判断的开销。
- 线程安全且没有延迟初始化。
- **缺点**：即使不使用该类的实例，实例也会在类加载时被创建，可能造成不必要的资源消耗。

### 3. **双重检查锁（Double-Checked Locking）**

双重检查锁可以在懒汉式基础上进行优化，以确保线程安全，同时避免每次获取实例时都进行同步。

- 使用 **`synchronized`** 锁定代码块来确保多线程访问时的安全性。
- **双重检查**：先检查实例是否已创建，若未创建才进入同步代码块。在同步块内再次检查实例是否为 `null`，如果是，再创建实例。
- **优点**：既能保证线程安全，又能避免每次访问时都进行同步，提高性能。

### 4. **静态内部类（Bill Pugh Singleton）**

利用 **静态内部类** 特性进行实现，它结合了懒汉式和饿汉式的优点。JVM保证静态类的初始化是线程安全的，且只会初始化一次。

- **静态内部类**：只有在调用 `getInstance()` 方法时，`SingletonHelper` 才会被加载并初始化，确保延迟加载。
- 线程安全，且 **性能高效**。
- **优点**：线程安全、延迟初始化、性能好。

## **单例模式的线程安全**

- **懒汉式**：如果多线程访问 `getInstance()` 方法且 `instance` 为 `null`，会创建多个实例。要确保线程安全，可以加锁，但会影响性能。
- **饿汉式**：实例在类加载时就创建，因此线程安全。
- **双重检查锁**：通过双重检查和同步，确保了懒汉式的线程安全和高性能。
- **静态内部类**：依赖静态内部类的初始化特性，线程安全且延迟加载。

## **单例模式的优缺点**

## 优点：

- **节省资源**：保证类只有一个实例，避免了不必要的资源浪费。
- **全局访问点**：提供了一个全局的访问点，使得系统中的不同部分可以共享这个唯一实例。
- **控制实例化**：控制类的实例化，避免了系统中出现多个对象。

## 缺点：

- **不易扩展**：单例模式限制了该类的扩展，如果未来需要多个实例或实例的多样化，单例模式会显得比较难以适应。
- **全局状态**：单例模式通常会引入全局状态，可能导致一些难以追踪的副作用或依赖。