# 策略模式

策略模式是一种行为型设计模式，用于定义一系列算法，将每一个算法封装起来，并让它们之间可以互相替换。策略模式让算法的变化独立于使用算法的客户（即客户端），从而使得算法的选择和变化不影响到客户代码的其他部分。

## **适用场景**

策略模式适用于以下场景：

1. **算法需要多种变体**：如果一个类需要根据不同的条件使用不同的算法，策略模式是很好的解决方案。它可以将不同的算法封装在不同的策略类中。
2. **避免条件判断语句**：当你需要用 `if-else` 或 `switch` 等语句来选择不同算法时，策略模式可以帮助你避免这些条件判断，使代码更加清晰。
3. **客户端可以灵活切换算法**：当你希望能够在运行时根据不同的需求选择不同的算法时，策略模式非常适合。

## **结构**

策略模式主要由以下几个部分组成：

1. **Context（上下文）**：持有一个 `Strategy` 对象的引用，并可以在运行时动态地改变 `Strategy`。它负责调用具体策略类来实现某个功能。
2. **Strategy（策略接口）**：定义一个算法族的公共接口。
3. **ConcreteStrategy（具体策略类）**：实现具体的算法或行为。

## **核心思想**

在策略模式中，我们将多种算法封装成多个策略类（`ConcreteStrategy`），这些策略类都实现一个统一的 `Strategy` 接口，客户端可以在运行时根据需要选择不同的策略来执行。这样就避免了在客户端中通过大量的条件判断来选择算法，提高了代码的可维护性和可扩展性。


## **优缺点**

### **优点**

- **开放/封闭原则**：增加新的策略只需要增加新的 `ConcreteStrategy` 类，而无需修改现有代码，符合 **开放/封闭原则**。
- **避免复杂的条件判断**：将条件判断移到了不同的策略类中，客户端只需选择需要的策略即可。
- **灵活性**：策略模式允许在运行时选择策略，从而提供了很高的灵活性。

### **缺点**

- **增加了类的数量**：每个策略都需要一个对应的类，如果策略较多，会增加类的数量，增加系统复杂性。
- **客户端需要知道所有策略类**：虽然策略类是解耦的，但客户端需要知道所有的策略类，并选择适合的策略。这增加了客户端的复杂度。