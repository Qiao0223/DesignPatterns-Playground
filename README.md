# 概述
设计模式是软件开发中的一种解决常见问题的通用方案，它通过总结经验和最佳实践，提供了一些被验证过的、可重用的设计方法。这些模式并不是直接的代码，而是描述了一种解决特定问题的方案，通常是在特定的上下文中被广泛使用。

设计模式主要分为三类：

## 1. **创建型模式**

这些模式关注如何实例化对象，或者如何通过不同的方式创建对象，增强系统的灵活性和可扩展性。

- **单例模式（Singleton）**：确保类只有一个实例，并提供全局访问点。
- **工厂方法模式（Factory Method）**：定义一个创建对象的接口，让子类决定实例化哪一个类。
- **抽象工厂模式（Abstract Factory）**：提供一个创建一系列相关或相互依赖对象的接口。
- **建造者模式（Builder）**：将复杂对象的创建过程分解为多个步骤，逐步构建出最终对象。
- **原型模式（Prototype）**：通过复制现有对象来创建新的对象，而不是通过直接构造。

## 2. 结构型模式

这些模式关注如何通过组合类和对象来处理复杂的结构，使得系统更易于扩展。

- **适配器模式（Adapter）**：将一个类的接口转换成客户端期望的另一个接口，使得本不兼容的类可以一起工作。
- **桥接模式（Bridge）**：将抽象与实现分离，使它们可以独立变化。
- **组合模式（Composite）**：将对象组合成树形结构，以便表示“部分—整体”的层次结构。
- **装饰器模式（Decorator）**：动态地给一个对象添加额外的职责，增强其功能。
- **外观模式（Facade）**：为复杂的子系统提供一个简化的接口。
- **享元模式（Flyweight）**：通过共享对象来减少内存使用，尤其是当对象的数量非常多时。
- **代理模式（Proxy）**：为其他对象提供代理，以控制对这个对象的访问。

## 3. 行为型模式

这些模式关注类和对象之间的通讯和责任分配，优化系统中的对象交互。

- **策略模式（Strategy）**：定义一系列算法，把它们一个个封装起来，并使它们可以互换。
- **模板方法模式（Template Method）**：定义一个算法的骨架，将一些步骤延迟到子类中实现。
- **命令模式（Command）**：将请求封装成一个对象，从而使你能够使用不同的请求、队列和日志来参数化对象。
- **责任链模式（Chain of Responsibility）**：通过将请求沿着处理链传递，直到有一个处理对象能够处理它。
- **状态模式（State）**：允许对象在其内部状态改变时改变其行为。
- **观察者模式（Observer）**：当一个对象的状态发生改变时，依赖于它的所有对象都会得到通知并自动更新。
- **中介者模式（Mediator）**：用一个中介对象来协调各个对象之间的交互，减少对象间的直接通信。
- **备忘录模式（Memento）**：在不暴露对象实现细节的情况下，捕获对象的内部状态，并在以后恢复。
- **迭代器模式（Iterator）**：提供一种方法，可以顺序访问集合中的元素，而不暴露集合的内部结构。
- **访问者模式（Visitor）**：允许在不改变元素类的前提下，向元素添加新的操作。

# 七大原则

设计模式的七大原则是软件设计中的一些关键理念，旨在提高代码的可复用性、可维护性和灵活性。下面是这七个原则的简要介绍：

## 1. 单一职责原则 (Single Responsibility Principle, SRP)
   **定义**：一个类应该只有一个改变的原因，换句话说，类应该只负责一项职能。

   **目的**：避免类承担过多的职责，减少因修改一个功能而影响到其他功能的风险。

## 2. 开放封闭原则 (Open/Closed Principle, OCP)
   **定义**：软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。

   **目的**：通过扩展已有功能而不是修改现有代码，确保代码在增加新功能时保持稳定性。

## 3. 里氏替换原则 (Liskov Substitution Principle, LSP)

   **定义**：子类对象应该能够替换父类对象，并且程序的行为不应因此产生错误。

   **目的**：保证继承关系的正确性，使得子类可以在任何需要父类的地方被使用，而不破坏原有系统的功能。

## 4. 接口隔离原则 (Interface Segregation Principle, ISP)
   **定义**：客户端不应该被迫依赖于它不使用的接口。

   **目的**：将大的接口拆分为多个小的、功能单一的接口，使得客户端只需关注它所使用的部分，减少冗余和耦合。

## 5. 依赖倒转原则 (Dependency Inversion Principle, DIP)
   **定义**：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。

   **目的**：通过依赖抽象来解耦高层模块和低层模块，使得代码更易于修改和扩展。

## 6. 合成复用原则 (Composite Reuse Principle, CRP)
   **定义**：优先通过对象组合来复用，而不是通过继承。

   **目的**：通过组合不同的对象和模块来实现代码的复用，避免继承带来的问题，如过度耦合和复杂的继承树。

## 7. 最少知识原则 (Least Knowledge Principle, Law of Demeter, LoD)
   **定义**：一个对象应当对其他对象有尽可能少的了解，即与其直接关联的对象进行交互，避免与“陌生”对象发生交互。

   **目的**：减少对象间的依赖关系，使得代码更加模块化和易于维护。